name: release

on:
  workflow_dispatch:
    inputs:
      bump:
        description: Which part to bump?
        required: true
        default: patch
        type: choice
        options: [patch, minor, major]
      notes:
        description: >-
          (Optional) Release notes in Markdown. If omitted, the workflow will
          pull the section for the new version from CHANGELOG.md.
        required: false
        type: string

permissions:
  contents: write  # required to push commits/tags and create releases

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Pester tests
        shell: pwsh
        run: |
          if (Test-Path "$PWD/tests") {
            Install-Module Pester -Force -Scope CurrentUser
            Invoke-Pester -CI
          } else {
            Write-Host "No tests/ folder found. Skipping."
          }

  release:
    needs: test
    runs-on: ubuntu-latest
    env:
      BUMP_PART: ${{ github.event.inputs.bump }}
      PSD1_PATH: src/ExpressionCache.psd1
      MANUAL_NOTES: ${{ github.event.inputs.notes }}
    steps:
      - name: Checkout (full history for tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bump module version in PSD1
        id: bump
        shell: pwsh
        run: |
          $psd1 = "${{ env.PSD1_PATH }}"
          if (-not (Test-Path $psd1)) { throw "Manifest not found at $psd1" }

          $manifest = Test-ModuleManifest $psd1
          $ver = [version]$manifest.Version

          switch ("${{ env.BUMP_PART }}") {
            'major' { $new = [version]"$($ver.Major + 1).0.0" }
            'minor' { $new = [version]"$($ver.Major).$($ver.Minor + 1).0" }
            default { $new = [version]"$($ver.Major).$($ver.Minor).$($ver.Build + 1)" }
          }

          Write-Host "Bumping version $ver -> $new"

          # Preserve/force critical fields so exports don't disappear
          $root = if ($manifest.RootModule) { $manifest.RootModule } else { 'ExpressionCache.psm1' }
          $fx   = if ($manifest.FunctionsToExport -and $manifest.FunctionsToExport.Count) { $manifest.FunctionsToExport } else { '*' }

          Update-ModuleManifest -Path $psd1 `
            -ModuleVersion $new `
            -RootModule $root `
            -FunctionsToExport $fx `
            -CmdletsToExport @() `
            -AliasesToExport @()

          "newVersion=$new" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Extract notes from CHANGELOG.md (if no manual notes)
        id: changelog
        if: ${{ !github.event.inputs.notes }}
        shell: pwsh
        run: |
          $ver = "${{ steps.bump.outputs.newVersion }}"
          $pattern = "^##\s+\[?$([regex]::Escape($ver))\]?(.*)$"

          if (-not (Test-Path "CHANGELOG.md")) {
            Write-Host "No CHANGELOG.md found; using fallback."
            $body = "Automated release $ver."
          } else {
            $lines = Get-Content CHANGELOG.md
            $match = $lines | Select-String -Pattern $pattern | Select-Object -First 1
            if (-not $match) {
              Write-Host "No changelog section found for $ver; using fallback."
              $body = "Automated release $ver."
            } else {
              $startIndex = $match.LineNumber - 1
              $rest = $lines[$startIndex..($lines.Length-1)]
              $nextHeader = ($rest | Select-String -Pattern '^##\s+' | Select-Object -Skip 1 -First 1)
              if ($nextHeader) {
                $endIndex = $nextHeader.LineNumber - 2
                $section = $rest[0..$endIndex]
              } else {
                $section = $rest
              }
              $body = ($section -join "`n").Trim()
            }
          }

          # Write multi-line output safely
          $delim = [guid]::NewGuid().ToString('n')
          Add-Content -Path $env:GITHUB_OUTPUT -Value "body<<$delim"
          Add-Content -Path $env:GITHUB_OUTPUT -Value $body
          Add-Content -Path $env:GITHUB_OUTPUT -Value $delim

      - name: Commit & tag
        shell: pwsh
        run: |
          git config user.name  "github-actions"
          git config user.email "actions@github.com"

          git add "${{ env.PSD1_PATH }}"
          git commit -m "chore(release): bump version to ${{ steps.bump.outputs.newVersion }} [skip ci]" || echo "No changes to commit."

          $branch = "${{ github.ref_name }}"
          git push origin "HEAD:$branch"

          $tag = "v${{ steps.bump.outputs.newVersion }}"
          git tag $tag
          git push origin $tag

      - name: Publish to PowerShell Gallery
        env:
          PSGALLERY_API_KEY: ${{ secrets.PSGALLERY_API_KEY }}
          MANUAL_NOTES: ${{ env.MANUAL_NOTES }}
          CHANGELOG_BODY: ${{ steps.changelog.outputs.body }}
          NEW_VERSION: ${{ steps.bump.outputs.newVersion }}
          PSD1_PATH: ${{ env.PSD1_PATH }}
        shell: pwsh
        run: |
          if (-not $env:PSGALLERY_API_KEY) { throw "PSGALLERY_API_KEY secret is not set." }

          # Decide release notes priority: manual > changelog > fallback
          if ($env:MANUAL_NOTES) {
            $notes = $env:MANUAL_NOTES
          } elseif ($env:CHANGELOG_BODY) {
            $notes = $env:CHANGELOG_BODY
          } else {
            $notes = "Automated release $env:NEW_VERSION."
          }

          # Safety cap for Gallery/NuGet release notes (multi-line supported)
          $max = 32000
          if ($notes.Length -gt $max) {
            $releaseUrl = "https://github.com/$env:GITHUB_REPOSITORY/releases/tag/v$env:NEW_VERSION"
            $suffix = "`n`n[...truncated â€” see full notes: $releaseUrl]"
            $notes = $notes.Substring(0, $max - $suffix.Length).TrimEnd() + $suffix
          }

          # Ensure PowerShellGet is available
          if (-not (Get-Module -ListAvailable PowerShellGet)) {
            Install-Module PowerShellGet -Force -Scope CurrentUser
          }

          # Resolve module paths & stage into <ModuleName>/ as required by Publish-Module
          $psd1 = $env:PSD1_PATH
          if (-not (Test-Path $psd1)) { throw "Manifest not found at $psd1" }
          $manifest   = Test-ModuleManifest $psd1
          $moduleName = $manifest.Name
          if (-not $moduleName) { $moduleName = [IO.Path]::GetFileNameWithoutExtension($psd1) }

          $srcDir     = Split-Path -Parent $psd1
          $stageRoot  = Join-Path $PWD 'pkg'
          $moduleDir  = Join-Path $stageRoot $moduleName
          Remove-Item $stageRoot -Recurse -Force -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $moduleDir -Force | Out-Null
          Copy-Item -Path (Join-Path $srcDir '*') -Destination $moduleDir -Recurse -Force

          # Force the staged manifest's ReleaseNotes to match $notes (so Gallery shows the right text)
          $stagedPsd1 = Join-Path $moduleDir (Split-Path -Leaf $psd1)
          Update-ModuleManifest -Path $stagedPsd1 -ReleaseNotes $notes

          # Optional: sanity print
          $rn = (Test-ModuleManifest $stagedPsd1).ReleaseNotes
          Write-Host "ReleaseNotes to publish:`n$rn"

          # Publish from the staged folder (manifest now contains the correct ReleaseNotes)
          Publish-Module -Path $moduleDir -NuGetApiKey $env:PSGALLERY_API_KEY -Verbose

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.bump.outputs.newVersion }}
          name: ExpressionCache v${{ steps.bump.outputs.newVersion }}
          body: ${{ github.event.inputs.notes || steps.changelog.outputs.body || format('Automated release {0}.', steps.bump.outputs.newVersion) }}
